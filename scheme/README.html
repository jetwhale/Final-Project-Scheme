<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Final Project Documentation</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Final Project Documentation</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Documenting_.Primitive_.Functions%29" class="tocviewlink" data-pltdoc="x">Documenting Primitive Functions</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Top-level_overview_of_compiler%29" class="tocviewlink" data-pltdoc="x">Top-<wbr></wbr>level overview of compiler</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Run-time_.Errors%29" class="tocviewlink" data-pltdoc="x">Run-<wbr></wbr>time Errors</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Final_.Project_.Documentation%29" class="tocsubseclink" data-pltdoc="x">Final Project Documentation</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Documenting_.Primitive_.Functions%29" class="tocsubseclink" data-pltdoc="x">Documenting Primitive Functions</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Top-level_overview_of_compiler%29" class="tocsubseclink" data-pltdoc="x">Top-<wbr></wbr>level overview of compiler</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Run-time_.Errors%29" class="tocsubseclink" data-pltdoc="x">Run-<wbr></wbr>time Errors</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">6.10</span></div><h2><a name="(part._.Final_.Project_.Documentation)"></a>Final Project Documentation</h2><p>High-Level Description and Documentation for Final Compilers Project</p><p>I, Sahil Mariwala, pledge on my honor that I have not given or
received any unauthorized assistance on this assignment.</p><h3>1<tt>&nbsp;</tt><a name="(part._.Documenting_.Primitive_.Functions)"></a>Documenting Primitive Functions</h3><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">b</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; int</p><p>Returns true if all arguments are equal.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">&gt;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">b</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; int</p><p>Returns true if a is greater than b.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">&lt;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">b</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; bool</p><p>Returns true if a is less than b.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">&lt;=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">b</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; bool</p><p>Returns true if a is less than or equal to b.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">&gt;=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">b</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; bool</p><p>Returns true if a is greater than b.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">b</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; int</p><p>Returns the sum of all arguments.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-</span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">b</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; int</p><p>Returns result of subtracting b from a.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">b</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; int</p><p>Returns product of all numbers.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">/</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">b</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; int</p><p>Divides first integer by second. Raises Divide by Zero error if second argument is 0.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">null?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; bool</p><p>Returns true if a is empty.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">b</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; pair</p><p>Returns a new pair where the first element is a and the second element is b.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">car</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; any</p><p>Returns the first element of the pair.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">cdr</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktMeta"></span>  &#8594; any</p><p>Returns the second element of the pair p.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">list</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; list</p><p>Returns a list with the a as an element in the list.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">length</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">lst</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; int</p><p>Returns the number of elements in the list provided.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">list-tail</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">lst</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; list</p><p>Returns the list after the first a elements of lst.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">member</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">lst</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; list/#f</p><p>Checks if a is an element of lst and then returns the tail of the list from a or false if not found.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">memv</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">v</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">lst</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; list/#f</p><p>Checks if a is an element of lst and then returns the tail of the list from a or false if not found using eqv? instead of equals?.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">map</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">proc</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">lst</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; list</p><p>Applies proc to all of the elements of lst. The result is a list with the result of proc applied to each element.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">append</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">lst</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; list</p><p>Compiles all elements in all lists supplied in order.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">foldl</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">proc</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">l</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">...+</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; list</p><p>foldl applies proc to each element in the list from left to right while containing an accumulator with behavior specified by proc.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">foldr</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">pro</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">l</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">...+</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; list</p><p>foldl applies proc to each element in the list from right to left while containing an accumulator with behavior specified by proc.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">vector?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; bool</p><p>Returns true if a is a vector.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">vector</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; vector</p><p>Returns a mutable vector v.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">make-vector</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">size</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">[</span><span class="RktSym">v</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; vector</p><p>Returns a mutable vector with size slots initialized to v.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">vector-ref</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">v</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">pos</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; any</p><p>Returns the element at index pos from v.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">vector-set!</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">v</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">pos</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; #&lt;void&gt;</p><p>Sets the element at index pos of vector v to a.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">vector-length</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; int</p><p>Returns the length of the vector.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">set</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">v</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; set</p><p>Creates a set with elements given.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">set-&gt;list</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; list</p><p>Returns a list with the elements from set s.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">list-&gt;set</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">lst</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; set</p><p>Creates a set with the elements of lst.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">list?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">lst</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; bool</p><p>Returns whether lst is a list, pair with list as the subsequent element or an empty list.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">void?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">v</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; bool</p><p>Returns true if v is constant #&lt;void&gt;.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">promise?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">p</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; bool</p><p>Returns true if p is a promise.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">number?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; bool</p><p>Returns true if n is a number.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">integer?</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; bool</p><p>Returns true if n is an integer.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">error</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; any</p><p>Raises an exception that returns a string "error: " with s appended to it.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">void</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">v</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; #&lt;void&gt;</p><p>Returns the constant #&lt;void&gt; with all arguments ignored.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">print</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">p</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; #&lt;void&gt;</p><p>Prints p.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">display</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">d</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; #&lt;void&gt;</p><p>Displays datum d.</p><p><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">exit</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktMeta"></span> &#8594; any</p><p>passes e to exit handler or returns #&lt;void&gt; if e is not present.</p><h3>2<tt>&nbsp;</tt><a name="(part._.Top-level_overview_of_compiler)"></a>Top-level overview of compiler</h3><p>Scheme input is wrapped in a <span class="RktMeta"></span><span class="RktSym">begin</span><span class="RktMeta"></span> and passes through <span class="RktMeta"></span><span class="RktSym">top-level</span><span class="RktMeta"></span> from assignment 5.</p><p>After passing through <span class="RktMeta"></span><span class="RktSym">top-level</span><span class="RktMeta"></span>, all datums become explicitly quoted, <span class="RktMeta"></span><span class="RktSym">defines</span><span class="RktMeta"></span> are desugared into <span class="RktMeta"></span><span class="RktSym">letrec*</span><span class="RktMeta"></span>, and new bindings are generated for expressions that contain <span class="RktMeta"></span><span class="RktSym">quasiquotes</span><span class="RktMeta"></span>, <span class="RktMeta"></span><span class="RktSym">unquotes</span><span class="RktMeta"></span>, and <span class="RktMeta"></span><span class="RktSym">match</span><span class="RktMeta"></span>.</p><p>The <span class="RktMeta"></span><span class="RktSym">top-level</span><span class="RktMeta"></span> output is then passed through <span class="RktMeta"></span><span class="RktSym">desugar</span><span class="RktMeta"></span> from assignment 2 which converts the input into a small core language including only let forms, lambdas, conditionals, set!, call/cc, and explicit primitive-operation forms.</p><p>The resulting output is fed to <span class="RktMeta"></span><span class="RktSym">assignment-convert</span><span class="RktMeta"></span> and <span class="RktMeta"></span><span class="RktSym">alphatize</span><span class="RktMeta"></span> which replaces <span class="RktMeta"></span><span class="RktSym">set!</span><span class="RktMeta"></span> with <span class="RktMeta"></span><span class="RktSym">make-vector</span><span class="RktMeta"></span>, <span class="RktMeta"></span><span class="RktSym">vector-set!</span><span class="RktMeta"></span>, and <span class="RktMeta"></span><span class="RktSym">vector-ref</span><span class="RktMeta"></span> prims.</p><p>The grammar is then partitioned by into complex expressions and atomic expressions that are able to be immediately evaluated by ANF conversion.</p><p>CPS conversion follows and the current continuation is invoked at return points instead of allowing function calls to return. As a result, <span class="RktMeta"></span><span class="RktSym">call/cc</span><span class="RktMeta"></span> is removed and <span class="RktMeta"></span><span class="RktSym">prims</span><span class="RktMeta"></span> and <span class="RktMeta"></span><span class="RktSym">apply-prims</span><span class="RktMeta"></span> are now let-bound.</p><p><span class="RktMeta"></span><span class="RktSym">closure-convert</span><span class="RktMeta"></span> conducts 2 passes on the output to lift the remaining variable references to let-bindings and turns fixed-arity functions into unary functions that take an argument list. One more pass transforms the language into a list of first-order procedures.</p><p>Finally, the grammar is turned into a string encoding LLVM IR. The header.cpp file is also transformed into LLVM IR and both are concatenated in a file combined.ll which is compiled with <span class="RktMeta"></span><span class="RktSym">clang++</span><span class="RktMeta"></span> to produce a valid binary.</p><h3>3<tt>&nbsp;</tt><a name="(part._.Run-time_.Errors)"></a>Run-time Errors</h3><p>The tests.rkt have been modified so error messages from the binary are returned. This is how I created tests that fail for certain runtime errors.</p><p>Integer Overflow for Addition, Multiplication, and Subtraction</p><p>Run integer_overflow_1 and integer_overflow_2. Header.cpp is modified such that the prim functions for +, - and * detect
an integer overflow and print "Integer Overflow Error" before halting.</p><p>Integer Underflow for Addition, Multiplication, and Subtraction</p><p>Run integer_underflow_1 and integer_underflow_2. Header.cpp is modified such that the prim functions for +, - and * detect
an integer overflow and print "Integer Overflow Error" before halting.</p><p>Division by Zero</p><p>Run divide_zero_1 and divide_zero_2. Header.cpp is modified such that the prim functions for / checks whether the second
argument is 0. If so, it prints "Divide By Zero Error" before halting.</p></div></div><div id="contextindicator">&nbsp;</div></body></html>